{% extends 'base.html' %}
{% block content %}
  <h1>Sudoku</h1>
  <p>Hi {{ session.name | default('Guest') }}! Hints left: <span id="hints">{{ session.hints_left | default(3) }}</span></p>
  <p>Time: <span id="timer">0</span>s</p>
  <select id="difficulty" onchange="startNewGame()">
    <option value="easy">Easy</option>
    <option value="medium" selected>Medium</option>
    <option value="hard">Hard</option>
  </select>
  <button onclick="startNewGame()">New Game</button>
  <button onclick="getHint()" id="hintBtn">Get Hint</button>
  <button onclick="submitPuzzle()">Submit</button>
  <div id="sudokuGrid"></div>
  <p id="msg" class="success">{{ session.pop('msg', '') }}</p>
  <p id="err" class="error">{{ session.pop('err', '') }}</p>
  <p><a href="{{ url_for('dashboard') }}">Back to Dashboard</a></p>
{% endblock %}
{% block scripts %}
  <script>
    // Initialize with robust JSON parsing
    let grid = [];
    let solution = [];
    try {
      const puzzleData = '{{ session.puzzle | tojson | safe | default('[]') }}';
      const solutionData = '{{ session.solution | tojson | safe | default('[]') }}';
      if (puzzleData && puzzleData !== 'null') {
        grid = JSON.parse(puzzleData);
      }
      if (solutionData && solutionData !== 'null') {
        solution = JSON.parse(solutionData);
      }
      console.log('Parsed grid:', grid);
      console.log('Parsed solution:', solution);
    } catch (e) {
      console.error('Failed to parse grid or solution:', e);
    }
    let startTime = {{ session.start_time | tojson | safe | default(0) }};

    // Validate grid and solution
    if (!Array.isArray(grid) || grid.length !== 9 || !grid.every(row => Array.isArray(row) && row.length === 9)) {
      console.warn('Invalid or empty grid, starting new game');
      startNewGame();
      return;
    }
    if (!Array.isArray(solution) || solution.length !== 9 || !solution.every(row => Array.isArray(row) && row.length === 9)) {
      console.warn('Invalid or empty solution, starting new game');
      startNewGame();
      return;
    }

    function createGrid() {
      const gridDiv = document.getElementById('sudokuGrid');
      gridDiv.innerHTML = '';
      const table = document.createElement('table');
      for (let r = 0; r < 9; r++) {
        const row = document.createElement('tr');
        for (let c = 0; c < 9; c++) {
          const cell = document.createElement('td');
          cell.className = `cell r${r} c${c} block${Math.floor(r/3)*3 + Math.floor(c/3)}`;
          const input = document.createElement('input');
          input.type = 'text';
          input.maxLength = 1;
          input.value = grid[r][c] || '';
          input.readOnly = grid[r][c] !== 0;
          input.oninput = (e) => updateGrid(r, c, e.target.value);
          input.onfocus = () => highlight(r, c);
          input.onblur = () => clearHighlight();
          input.onkeypress = (e) => {
            const char = String.fromCharCode(e.which);
            if (!/[1-9]/.test(char)) e.preventDefault();
          };
          cell.appendChild(input);
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
      gridDiv.appendChild(table);
      updateTimer();
      console.log('Grid rendered');
    }

    function updateGrid(r, c, value) {
      const num = parseInt(value) || 0;
      if (num >= 0 && num <= 9) {
        grid[r][c] = num;
      } else {
        grid[r][c] = 0;
        document.querySelector(`.r${r}.c${c} input`).value = '';
      }
    }

    function highlight(r, c) {
      clearHighlight();
      document.querySelectorAll(`.r${r} input, .c${c} input, .block${Math.floor(r/3)*3 + Math.floor(c/3)} input`)
        .forEach(input => input.classList.add('highlight'));
    }

    function clearHighlight() {
      document.querySelectorAll('.highlight').forEach(input => input.classList.remove('highlight'));
    }

    function updateTimer() {
      if (startTime) {
        const seconds = Math.floor((Date.now() / 1000) - startTime);
        document.getElementById('timer').textContent = seconds;
        setTimeout(updateTimer, 1000);
      }
    }

    function startNewGame() {
      const difficulty = document.getElementById('difficulty').value;
      fetch('/play', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `difficulty=${difficulty}`
      }).then(response => {
        if (response.redirected) {
          window.location.href = response.url;
        }
      }).catch(error => {
        console.error('Failed to start new game:', error);
        document.getElementById('err').textContent = 'Failed to start new game';
      });
    }

    function getHint() {
      fetch('/hint', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
          if (data.error) {
            document.getElementById('err').textContent = data.error;
            return;
          }
          grid[data.row][data.col] = data.value;
          const input = document.querySelector(`.r${data.row}.c${data.col} input`);
          input.value = data.value;
          input.readOnly = true;
          document.getElementById('hints').textContent = data.hints_left;
          if (data.hints_left === 0) {
            document.getElementById('hintBtn').disabled = true;
          }
          document.getElementById('err').textContent = '';
        }).catch(error => {
          console.error('Hint request failed:', error);
          document.getElementById('err').textContent = 'Failed to get hint';
        });
    }

    function validatePuzzle() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (grid[r][c] === 0 || grid[r][c] !== solution[r][c]) {
            return false;
          }
        }
      }
      return true;
    }

    function submitPuzzle() {
      if (!validatePuzzle()) {
        document.getElementById('err').textContent = 'Puzzle incomplete or incorrect';
        alert('Puzzle is incomplete or contains errors. Please check your entries.');
        return;
      }
      fetch('/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ grid: grid })
      })
        .then(response => response.json())
        .then(data => {
          if (data.error) {
            document.getElementById('err').textContent = data.error;
            alert(data.error);
          } else {
            document.getElementById('msg').textContent = `Puzzle submitted in ${data.seconds} seconds!`;
            alert(`Success! Puzzle completed in ${data.seconds} seconds.`);
            window.location.href = '/dashboard';
          }
        })
        .catch(error => {
          console.error('Submission failed:', error);
          document.getElementById('err').textContent = 'Submission failed';
          alert('Submission failed: ' + error.message);
        });
    }

    window.onload = () => {
      {% if not session.user_id %}
        alert('Playing in Guest Mode: Your scores will not be saved, shown on the leaderboard, or included in PDFs.');
      {% endif %}
      if (!grid.length || !solution.length) {
        console.warn('Grid or solution empty, starting new game');
        startNewGame();
      } else {
        createGrid();
      }
    };
  </script>
  <style>
    table { 
      border-collapse: collapse; 
      margin: 20px 0; 
      border: 3px solid #333; 
    }
    .cell { 
      width: 40px; 
      height: 40px; 
      border: 1px solid #999; 
      text-align: center; 
    }
    .cell input { 
      width: 100%; 
      height: 100%; 
      border: none; 
      text-align: center; 
      font-size: 16px; 
      background: transparent; 
    }
    .cell input:read-only { 
      background: #f0f0f0; 
      color: #333; 
    }
    .cell input:read-only.dark { 
      background: #555; 
      color: #fff; 
    }
    .highlight { 
      background: #d0d0ff; 
    }
    .highlight.dark { 
      background: #6666cc; 
    }
    .success { 
      color: green; 
    }
    .error { 
      color: red; 
    }
    /* 3x3 subgrid borders */
    .r0, .r3, .r6 { 
      border-top: 3px solid #333; 
    }
    .c0, .c3, .c6 { 
      border-left: 3px solid #333; 
    }
    .r8 { 
      border-bottom: 3px solid #333; 
    }
    .c8 { 
      border-right: 3px solid #333; 
    }
    /* Theme-specific styles */
    table.dark { 
      border-color: #ccc; 
      background: #444; 
    }
    .cell.dark { 
      border-color: #ccc; 
    }
    .cell input.dark { 
      color: #fff; 
      background: #444; 
    }
  </style>
{% endblock %}
